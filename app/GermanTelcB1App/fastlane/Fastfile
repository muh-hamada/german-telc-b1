# Fastfile for Telc Exam Apps
# This file contains the fastlane.tools configuration for Android and iOS releases

default_platform(:android)

# Path to update messages JSON file
UPDATE_MESSAGES_PATH = File.expand_path("../../update-messages.json", __dir__)

# Path to App Store metadata JSON file
APP_STORE_METADATA_PATH = File.expand_path("app-store-metadata.json", __dir__)

# Helper method to load update messages
def load_update_message(index)
  unless File.exist?(UPDATE_MESSAGES_PATH)
    UI.user_error!("Update messages file not found at: #{UPDATE_MESSAGES_PATH}")
  end
  
  messages = JSON.parse(File.read(UPDATE_MESSAGES_PATH))
  
  if index < 0 || index >= messages.length
    UI.user_error!("Invalid message index: #{index}. Must be between 0 and #{messages.length - 1}")
  end
  
  messages[index]
end

# Helper method to load and process App Store metadata
def load_app_store_metadata(app_id)
  unless File.exist?(APP_STORE_METADATA_PATH)
    UI.user_error!("App Store metadata file not found at: #{APP_STORE_METADATA_PATH}")
  end
  
  metadata = JSON.parse(File.read(APP_STORE_METADATA_PATH))
  
  # Parse app_id to extract language and level
  # Format: "german-a1", "german-a2", "german-b1", "german-b2", "english-b1", "english-b2", "dele-spanish-b1"
  parts = app_id.split('-')
  
  # Handle special case for "dele-spanish-b1"
  if parts.length == 3 && parts[0] == "dele"
    language = parts[1]  # "spanish"
    level = parts[2].upcase  # "B1"
  else
    language = parts[0]  # "german" or "english"
    level = parts[1].upcase  # "A1", "B1", "B2"
  end
  
  # Create a processed metadata hash with placeholders replaced
  processed = {}
  
  # Process descriptions for all locales
  processed[:description] = {}
  metadata["description"].each do |locale, template|
    # Map locale codes (en, de, etc.) to full locale codes for App Store
    locale_map = {
      "en" => "en-US",
      "de" => "de-DE",
      "es" => "es-ES",
      "fr" => "fr-FR",
      "it" => "it-IT",
      "pt" => "pt-PT",
      "ru" => "ru-RU",
      "ar" => "ar",
      "tr" => "tr-TR"
    }
    
    full_locale = locale_map[locale] || locale
    
    # Get localized language name
    language_name = metadata["languages"][language][locale]
    
    # Get localized country name
    country_name = metadata["countries"][language][locale]
    
    # Get localized level name
    level_name = metadata["level_names"][level][locale]
    
    # Replace placeholders
    text = template.gsub("{{LANGUAGE}}", language_name)
                   .gsub("{{LEVEL}}", level)
                   .gsub("{{LEVEL_NAME}}", level_name)
                   .gsub("{{COUNTRY}}", country_name)
    
    processed[:description][full_locale] = text
  end
  
  # Process keywords for all locales
  processed[:keywords] = {}
  metadata["keywords"].each do |locale, template|
    locale_map = {
      "en" => "en-US",
      "de" => "de-DE",
      "es" => "es-ES",
      "fr" => "fr-FR",
      "it" => "it-IT",
      "pt" => "pt-PT",
      "ru" => "ru-RU",
      "ar" => "ar",
      "tr" => "tr-TR"
    }
    
    full_locale = locale_map[locale] || locale
    language_name = metadata["languages"][language][locale]
    
    text = template.gsub("{{LANGUAGE}}", language_name)
                   .gsub("{{LEVEL}}", level)
    
    processed[:keywords][full_locale] = text
  end
  
  # URLs are the same for all apps
  processed[:support_url] = metadata["support_url"]
  processed[:marketing_url] = metadata["marketing_url"]
  
  processed
end

# Helper method to remove emojis from text (for App Store)
def remove_emojis(text)
  # Remove all emoji characters and extra spaces
  text.gsub(/[\u{1F300}-\u{1F9FF}]|[\u{2600}-\u{26FF}]|[\u{2700}-\u{27BF}]/u, '')
      .gsub(/\s+/, ' ')  # Replace multiple spaces with single space
      .strip             # Remove leading/trailing whitespace
end

# Helper method to write Play Store changelogs
def write_play_store_changelogs(package_name, update_message)
  # Base metadata path (absolute path using fastlane directory)
  # Use File.expand_path to ensure we get an absolute path
  # NOTE: We don't include package_name in the path - fastlane handles that via the package_name parameter
  base_metadata_path = File.expand_path(File.join(__dir__, "metadata", "android"))
  
  # Create base metadata directory first
  FileUtils.mkdir_p(base_metadata_path)
  
  # Language mapping for Play Store (Play Store uses different locale codes)
  locale_mapping = {
    "en" => "en-US",
    "de" => "de-DE",
    "es" => "es-ES",
    "fr" => "fr-FR",
    "it" => "it-IT",
    "pt" => "pt-PT",
    "ru" => "ru-RU",
    "ar" => "ar",
    "tr" => "tr-TR"
  }
  
  locale_mapping.each do |msg_key, play_locale|
    # Validate that the message exists for this language
    unless update_message[msg_key]
      UI.error("‚ö†Ô∏è  Warning: Missing translation for '#{msg_key}', using English as fallback")
      changelog_text = update_message["en"] || "Bug fixes and improvements"
    else
      changelog_text = update_message[msg_key]
    end
    
    # Write changelogs directly under locale directories (no package name in path)
    changelog_dir = File.join(base_metadata_path, play_locale, "changelogs")
    FileUtils.mkdir_p(changelog_dir)
    
    # Write the changelog (filename doesn't matter for new releases)
    changelog_file = File.join(changelog_dir, "default.txt")
    File.write(changelog_file, changelog_text)
  end
  
  UI.message("   üìù Changelogs written to: #{base_metadata_path}")
  
  # Return absolute path to base metadata directory
  base_metadata_path
end

# Helper method to get app configuration
def get_app_config(app_id)
  case app_id
  when "german-a1"
    {
      android_package: "com.mhamada.telca1german",
      ios_bundle_id: "com.mhamada.telca1german"
    }
  when "german-a2"
    {
      android_package: "com.mhamada.telca2german",
      ios_bundle_id: "com.mhamada.telca2german"
    }
  when "german-b1"
    {
      android_package: "com.mhamada.telcb1german",
      ios_bundle_id: "com.mhamada.telcb1german"
    }
  when "german-b2"
    {
      android_package: "com.mhamada.telcb2german",
      ios_bundle_id: "com.mhamada.telcb2german"
    }
  when "english-b1"
    {
      android_package: "com.mhamada.telcb1english",
      ios_bundle_id: "com.mhamada.telcb1english"
    }
  when "english-b2"
    {
      android_package: "com.mhamada.telcb2english",
      ios_bundle_id: "com.mhamada.telcb2english"
    }
  when "dele-spanish-b1"
    {
      android_package: "com.mhamada.deleb1spanish",
      ios_bundle_id: "com.mhamada.deleb1spanish"
    }
  else
    UI.user_error!("Unknown app ID: #{app_id}")
  end
end

# Helper method to wait for build to be available in App Store Connect
def wait_for_build_processing(bundle_id, build_number, max_wait_minutes: 10)
  UI.message("‚è≥ Waiting for build #{build_number} to be processed by TestFlight...")
  
  max_attempts = max_wait_minutes * 4  # Check every 15 seconds
  attempt = 0
  
  while attempt < max_attempts
    begin
      # Login to App Store Connect first
      Spaceship::ConnectAPI.login
      
      # Get the app
      app = Spaceship::ConnectAPI::App.find(bundle_id)
      
      unless app
        UI.error("Could not find app with bundle ID: #{bundle_id}")
        sleep(15)
        attempt += 1
        next
      end
      
      # Get all builds for this app
      builds = app.get_builds(
        filter: { version: build_number.to_s },
        includes: "preReleaseVersion",
        limit: 1
      )
      
      build = builds.first
      
      if build
        # Check if build is processed
        if build.processing_state == "VALID" || build.processing_state == "PROCESSING_COMPLETE"
          UI.success("‚úÖ Build #{build_number} is ready! (State: #{build.processing_state})")
          return true
        else
          UI.message("   Build found but still processing... State: #{build.processing_state} (attempt #{attempt + 1}/#{max_attempts})")
        end
      else
        UI.message("   Build #{build_number} not found yet... (attempt #{attempt + 1}/#{max_attempts})")
      end
      
      sleep(15)  # Wait 15 seconds before checking again
      attempt += 1
      
    rescue => e
      UI.message("   Error checking build: #{e.message} (attempt #{attempt + 1}/#{max_attempts})")
      sleep(15)
      attempt += 1
    end
  end
  
  UI.error("‚ö†Ô∏è  Build #{build_number} was not processed within #{max_wait_minutes} minutes")
  UI.error("   This could mean:")
  UI.error("   1. The build is taking longer than usual to process")
  UI.error("   2. There was an issue with the build upload")
  UI.error("   Please check TestFlight in App Store Connect manually")
  return false
end

platform :android do
  desc "Upload AAB to Google Play Store and create release"
  lane :release do |options|
    # Validate required parameters
    unless options[:app_id]
      UI.user_error!("app_id parameter is required")
    end
    
    unless options[:aab_path]
      UI.user_error!("aab_path parameter is required")
    end
    
    unless options[:message_index]
      UI.user_error!("message_index parameter is required")
    end
    
    app_config = get_app_config(options[:app_id])
    package_name = app_config[:android_package]
    aab_path = options[:aab_path]
    message_index = options[:message_index].to_i
    rollout = options[:rollout] || 1.0  # Default to 100% rollout
    track = options[:track] || "production"
    
    # Validate AAB file exists
    unless File.exist?(aab_path)
      UI.user_error!("AAB file not found at: #{aab_path}")
    end
    
    # Load update message
    update_message = load_update_message(message_index)
    
    UI.message("üì¶ Uploading to Play Store...")
    UI.message("   App: #{options[:app_id]}")
    UI.message("   Package: #{package_name}")
    UI.message("   AAB: #{aab_path}")
    UI.message("   Track: #{track}")
    UI.message("   Rollout: #{(rollout * 100).to_i}%")
    
    # Write changelogs to metadata directory
    metadata_path = write_play_store_changelogs(package_name, update_message)
    
    # Upload to Google Play
    upload_to_play_store(
      package_name: package_name,
      aab: aab_path,
      track: track,
      rollout: rollout,  # Already a float, no need to convert to string
      release_status: "completed",
      metadata_path: metadata_path,
      skip_upload_metadata: true,
      skip_upload_images: true,
      skip_upload_screenshots: true,
      skip_upload_changelogs: false
    )
    
    UI.success("‚úÖ Successfully uploaded #{options[:app_id]} to Google Play Store!")
  end
end

platform :ios do
  desc "Create release in App Store Connect and submit for review"
  lane :release do |options|
    # Validate required parameters
    unless options[:app_id]
      UI.user_error!("app_id parameter is required")
    end
    
    unless options[:version]
      UI.user_error!("version parameter is required")
    end
    
    unless options[:build_number]
      UI.user_error!("build_number parameter is required")
    end
    
    unless options[:message_index]
      UI.user_error!("message_index parameter is required")
    end
    
    app_config = get_app_config(options[:app_id])
    bundle_id = app_config[:ios_bundle_id]
    version = options[:version]
    build_number = options[:build_number]
    message_index = options[:message_index].to_i
    
    # Load update message
    update_message = load_update_message(message_index)
    
    # Load App Store metadata with placeholders replaced
    app_metadata = load_app_store_metadata(options[:app_id])
    
    # Remove emojis from messages for App Store (App Store rejects emojis in release notes)
    # TODO: Enable multi-language support once localizations are set up in App Store Connect
    # For now, only using English (en-US)
    ios_message = {
      "en-US" => remove_emojis(update_message["en"])
    }
    
    # Use English-only metadata
    english_metadata = {
      description: { "en-US" => app_metadata[:description]["en-US"] },
      keywords: { "en-US" => app_metadata[:keywords]["en-US"] },
      support_url: { "en-US" => app_metadata[:support_url] },
      marketing_url: { "en-US" => app_metadata[:marketing_url] }
    }
    
    # Multi-language support (commented out until localizations are set up):
    # ios_message = {}
    # update_message.each do |locale_key, msg|
    #   locale_map = {
    #     "en" => "en-US", "de" => "de-DE", "es" => "es-ES", "fr" => "fr-FR",
    #     "it" => "it-IT", "pt" => "pt-PT", "ru" => "ru-RU", "ar" => "ar", "tr" => "tr-TR"
    #   }
    #   full_locale = locale_map[locale_key] || locale_key
    #   ios_message[full_locale] = remove_emojis(msg)
    # end
    #
    # Multi-language metadata (commented out):
    # description: app_metadata[:description],
    # keywords: app_metadata[:keywords],
    # support_url: app_metadata[:description].keys.map { |locale| [locale, app_metadata[:support_url]] }.to_h,
    # marketing_url: app_metadata[:description].keys.map { |locale| [locale, app_metadata[:marketing_url]] }.to_h,
    
    UI.message("üçé Creating App Store release...")
    UI.message("   App: #{options[:app_id]}")
    UI.message("   Bundle ID: #{bundle_id}")
    UI.message("   Version: #{version}")
    UI.message("   Build: #{build_number}")
    
    # Wait for build to be processed by TestFlight (max 10 minutes)
    unless wait_for_build_processing(bundle_id, build_number, max_wait_minutes: 10)
      UI.user_error!("Build #{build_number} not ready. Please check TestFlight and try again later.")
    end
    
    # Create/update app version in App Store Connect
    deliver(
      app_identifier: bundle_id,
      app_version: version,
      build_number: build_number.to_s,  # Ensure build_number is a string
      skip_binary_upload: true,
      skip_screenshots: true,
      skip_metadata: false,  # Enable metadata upload
      force: true,
      submit_for_review: true,  # Auto-submit enabled (ITSAppUsesNonExemptEncryption in Info.plist handles encryption)
      automatic_release: true,
      
      # Release notes (English only)
      release_notes: ios_message,
      
      # App metadata (English only)
      description: english_metadata[:description],
      keywords: english_metadata[:keywords],
      support_url: english_metadata[:support_url],
      marketing_url: english_metadata[:marketing_url]
    )
    
    UI.success("‚úÖ Successfully created and submitted release for #{options[:app_id]} in App Store Connect!")
    
    UI.success("‚úÖ Successfully created and submitted release for #{options[:app_id]} in App Store Connect!")
  end
end
